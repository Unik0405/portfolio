<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Nikhil Narendiran | Portfolio</title>
  <meta name="description" content="Architect portfolio presented as a book-style viewer." />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Libre+Caslon+Text:wght@400;700&family=Work+Sans:wght@400;500;600&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <main class="viewer">
    <header class="viewer-header">
      <div class="title">
        <p class="eyebrow">Architect Portfolio</p>
        <h1>Nikhil Narendiran</h1>
      </div>
      <div class="controls">
        <button class="control-btn" id="prev" type="button">Previous</button>
        <span class="status" id="status">Loading…</span>
        <button class="control-btn" id="next" type="button">Next</button>
        <a class="control-link" href="Folio-final-sheets-for-issu.pdf" target="_blank" rel="noopener">Open PDF</a>
      </div>
    </header>

    <section class="book" id="book">
      <div class="page-shell" id="page-shell">
        <canvas id="page-left"></canvas>
        <canvas id="page-right"></canvas>
      </div>
      <div class="loading" id="loading">Loading portfolio…</div>
    </section>

    <footer class="viewer-footer">
      <p>Use arrow keys or the buttons to flip pages. On smaller screens the view switches to single-page mode.</p>
    </footer>
  </main>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    const pdfUrl = "Folio-final-sheets-for-issu.pdf";
    const statusEl = document.getElementById("status");
    const prevBtn = document.getElementById("prev");
    const nextBtn = document.getElementById("next");
    const loadingEl = document.getElementById("loading");
    const pageShell = document.getElementById("page-shell");
    const leftCanvas = document.getElementById("page-left");
    const rightCanvas = document.getElementById("page-right");
    const leftCtx = leftCanvas.getContext("2d");
    const rightCtx = rightCanvas.getContext("2d");

    let pdfDoc = null;
    let spreadIndex = 0;
    let singlePage = 1;
    let renderToken = 0;
    let lastModeSingle = false;

    const screenSingle = () => window.matchMedia("(max-width: 900px)").matches;
    const useSingleView = () => screenSingle();

    const getGap = () => {
      const gapValue = getComputedStyle(pageShell).getPropertyValue("--page-gap");
      const gap = parseFloat(gapValue);
      return Number.isFinite(gap) ? gap : 20;
    };

    const maxSpreadIndex = () => Math.floor((pdfDoc?.numPages || 0) / 2);
    const getLeftPage = () => spreadIndex * 2;
    const getRightPage = () => getLeftPage() + 1;

    const syncMode = () => {
      const nowSingle = useSingleView();
      if (nowSingle !== lastModeSingle) {
        if (nowSingle) {
          singlePage = Math.max(1, getLeftPage());
        } else {
          spreadIndex = Math.floor(singlePage / 2);
        }
        lastModeSingle = nowSingle;
      }
    };

    const renderBlank = (canvas, width, height) => {
      const outputScale = window.devicePixelRatio || 1;
      canvas.width = Math.max(1, Math.floor(width * outputScale));
      canvas.height = Math.max(1, Math.floor(height * outputScale));
      canvas.style.width = `${width}px`;
      canvas.style.height = `${height}px`;
      const ctx = canvas.getContext("2d");
      ctx.save();
      ctx.scale(outputScale, outputScale);
      ctx.fillStyle = "#000000";
      ctx.fillRect(0, 0, width, height);
      ctx.restore();
    };

    const renderPage = async (pageNumber, canvas, ctx, targetWidth) => {
      const page = await pdfDoc.getPage(pageNumber);
      const viewport = page.getViewport({ scale: 1 });
      const scale = targetWidth / viewport.width;
      const outputScale = window.devicePixelRatio || 1;
      const scaledViewport = page.getViewport({ scale: scale * outputScale });

      canvas.width = Math.floor(scaledViewport.width);
      canvas.height = Math.floor(scaledViewport.height);
      canvas.style.width = `${scaledViewport.width / outputScale}px`;
      canvas.style.height = `${scaledViewport.height / outputScale}px`;

      await page.render({ canvasContext: ctx, viewport: scaledViewport }).promise;
      return {
        width: scaledViewport.width / outputScale,
        height: scaledViewport.height / outputScale,
      };
    };

    const updateControls = () => {
      const totalPages = pdfDoc?.numPages || 0;
      const singleMode = useSingleView();
      const atStart = singleMode ? singlePage <= 1 : spreadIndex <= 0;
      const atEnd = singleMode ? singlePage >= totalPages : spreadIndex >= maxSpreadIndex();

      prevBtn.disabled = atStart;
      nextBtn.disabled = atEnd;

      if (!totalPages) {
        statusEl.textContent = "Loading…";
        return;
      }

      if (singleMode) {
        statusEl.textContent = `Page ${singlePage} of ${totalPages}`;
      } else {
        statusEl.textContent = `Pages ${getLeftPage()}-${getRightPage()} of ${totalPages}`;
      }
    };

    const renderSpread = async () => {
      if (!pdfDoc) return;
      const token = ++renderToken;
      loadingEl.classList.add("is-visible");

      syncMode();
      const singleMode = useSingleView();
      pageShell.classList.toggle("single", singleMode);

      const gap = getGap();
      const availableWidth = pageShell.clientWidth - (singleMode ? 0 : gap);
      const pageWidth = singleMode ? availableWidth : availableWidth / 2;

      if (singleMode) {
        rightCanvas.classList.add("is-hidden");
        await renderPage(singlePage, leftCanvas, leftCtx, pageWidth);
        if (token !== renderToken) return;
      } else {
        rightCanvas.classList.remove("is-hidden");
        const leftPageNumber = getLeftPage();
        const rightPageNumber = getRightPage();

        if (leftPageNumber === 0) {
          const rightSize = await renderPage(rightPageNumber, rightCanvas, rightCtx, pageWidth);
          if (token !== renderToken) return;
          renderBlank(leftCanvas, rightSize.width, rightSize.height);
        } else {
          const leftSize = await renderPage(leftPageNumber, leftCanvas, leftCtx, pageWidth);
          if (token !== renderToken) return;
          if (rightPageNumber <= pdfDoc.numPages) {
            await renderPage(rightPageNumber, rightCanvas, rightCtx, pageWidth);
            if (token !== renderToken) return;
          } else {
            renderBlank(rightCanvas, leftSize.width, leftSize.height);
          }
        }
      }

      updateControls();
      loadingEl.classList.remove("is-visible");
    };

    const clampState = () => {
      if (!pdfDoc) return;
      if (useSingleView()) {
        singlePage = Math.max(1, Math.min(singlePage, pdfDoc.numPages));
      } else {
        spreadIndex = Math.max(0, Math.min(spreadIndex, maxSpreadIndex()));
      }
    };

    prevBtn.addEventListener("click", () => {
      if (useSingleView()) {
        singlePage -= 1;
      } else {
        spreadIndex -= 1;
      }
      clampState();
      renderSpread();
    });

    nextBtn.addEventListener("click", () => {
      if (useSingleView()) {
        singlePage += 1;
      } else {
        spreadIndex += 1;
      }
      clampState();
      renderSpread();
    });

    window.addEventListener("keydown", (event) => {
      if (event.key === "ArrowRight") {
        nextBtn.click();
      }
      if (event.key === "ArrowLeft") {
        prevBtn.click();
      }
    });

    let resizeTimer = null;
    window.addEventListener("resize", () => {
      if (resizeTimer) window.clearTimeout(resizeTimer);
      resizeTimer = window.setTimeout(() => {
        syncMode();
        clampState();
        renderSpread();
      }, 150);
    });

    pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
    pdfjsLib.getDocument(pdfUrl).promise
      .then((pdf) => {
        pdfDoc = pdf;
        spreadIndex = 0;
        singlePage = 1;
        lastModeSingle = useSingleView();
        clampState();
        renderSpread();
      })
      .catch((error) => {
        console.error(error);
        loadingEl.textContent = "Unable to load the portfolio. Please use the Open PDF link.";
      });
  </script>
</body>
</html>
