<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Nikhil Narendiran | Portfolio</title>
  <meta name="description" content="Architect portfolio presented as a book-style viewer." />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Libre+Caslon+Text:wght@400;700&family=Work+Sans:wght@400;500;600&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <main class="viewer">
    <header class="viewer-header">
      <div class="title">
        <p class="eyebrow">Architect Portfolio</p>
        <h1>Nikhil Narendiran</h1>
      </div>
      <div class="controls">
        <button class="control-btn" id="prev" type="button">Previous</button>
        <span class="status" id="status">Loading…</span>
        <button class="control-btn" id="next" type="button">Next</button>
        <a class="control-link" href="Nikhil-Narendiran-Portfolio.pdf" target="_blank" rel="noopener">Open PDF</a>
      </div>
    </header>

    <section class="book" id="book">
      <div class="page-shell" id="page-shell">
        <canvas id="page-left"></canvas>
        <canvas id="page-right"></canvas>
      </div>
      <div class="loading" id="loading">Loading portfolio…</div>
    </section>

    <footer class="viewer-footer">
      <p>Use arrow keys or the buttons to flip pages. On smaller screens the view switches to single-page mode.</p>
    </footer>
  </main>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    const pdfUrl = "Nikhil-Narendiran-Portfolio.pdf";
    const statusEl = document.getElementById("status");
    const prevBtn = document.getElementById("prev");
    const nextBtn = document.getElementById("next");
    const loadingEl = document.getElementById("loading");
    const pageShell = document.getElementById("page-shell");
    const leftCanvas = document.getElementById("page-left");
    const rightCanvas = document.getElementById("page-right");
    const leftCtx = leftCanvas.getContext("2d");
    const rightCtx = rightCanvas.getContext("2d");

    let pdfDoc = null;
    let currentPage = 1;
    let renderToken = 0;
    let forceSingle = false;

    const screenSingle = () => window.matchMedia("(max-width: 900px)").matches;
    const useSingleView = () => forceSingle || screenSingle();

    const getGap = () => {
      const gapValue = getComputedStyle(pageShell).getPropertyValue("--page-gap");
      const gap = parseFloat(gapValue);
      return Number.isFinite(gap) ? gap : 20;
    };

    const renderBlank = (canvas, width, height) => {
      const outputScale = window.devicePixelRatio || 1;
      canvas.width = Math.max(1, Math.floor(width * outputScale));
      canvas.height = Math.max(1, Math.floor(height * outputScale));
      canvas.style.width = `${width}px`;
      canvas.style.height = `${height}px`;
      const ctx = canvas.getContext("2d");
      ctx.save();
      ctx.scale(outputScale, outputScale);
      ctx.fillStyle = "#fdfaf4";
      ctx.fillRect(0, 0, width, height);
      ctx.restore();
    };

    const renderPage = async (pageNumber, canvas, ctx, targetWidth) => {
      const page = await pdfDoc.getPage(pageNumber);
      const viewport = page.getViewport({ scale: 1 });
      const scale = targetWidth / viewport.width;
      const outputScale = window.devicePixelRatio || 1;
      const scaledViewport = page.getViewport({ scale: scale * outputScale });

      canvas.width = Math.floor(scaledViewport.width);
      canvas.height = Math.floor(scaledViewport.height);
      canvas.style.width = `${scaledViewport.width / outputScale}px`;
      canvas.style.height = `${scaledViewport.height / outputScale}px`;

      await page.render({ canvasContext: ctx, viewport: scaledViewport }).promise;
      return {
        width: scaledViewport.width / outputScale,
        height: scaledViewport.height / outputScale,
      };
    };

    const updateControls = () => {
      const totalPages = pdfDoc?.numPages || 0;
      const singleMode = useSingleView();
      const maxLeftPage = totalPages % 2 === 0 ? totalPages - 1 : totalPages;
      const atStart = currentPage <= 1;
      const atEnd = singleMode ? currentPage >= totalPages : currentPage >= maxLeftPage;

      prevBtn.disabled = atStart;
      nextBtn.disabled = atEnd;

      if (!totalPages) {
        statusEl.textContent = "Loading…";
        return;
      }

      if (singleMode) {
        statusEl.textContent = `Page ${currentPage} of ${totalPages}`;
      } else {
        const rightPage = Math.min(currentPage + 1, totalPages);
        statusEl.textContent = `Pages ${currentPage}-${rightPage} of ${totalPages}`;
      }
    };

    const renderSpread = async () => {
      if (!pdfDoc) return;
      const token = ++renderToken;
      loadingEl.classList.add("is-visible");

      const singleMode = useSingleView();
      pageShell.classList.toggle("single", singleMode);

      const gap = getGap();
      const availableWidth = pageShell.clientWidth - (singleMode ? 0 : gap);
      const pageWidth = singleMode ? availableWidth : availableWidth / 2;

      const leftSize = await renderPage(currentPage, leftCanvas, leftCtx, pageWidth);
      if (token !== renderToken) return;

      if (singleMode) {
        rightCanvas.classList.add("is-hidden");
      } else {
        rightCanvas.classList.remove("is-hidden");
        const rightPageNumber = currentPage + 1;
        if (rightPageNumber <= pdfDoc.numPages) {
          rightCanvas.classList.remove("is-empty");
          await renderPage(rightPageNumber, rightCanvas, rightCtx, pageWidth);
        } else {
          rightCanvas.classList.add("is-empty");
          renderBlank(rightCanvas, leftSize.width, leftSize.height);
        }
      }

      updateControls();
      loadingEl.classList.remove("is-visible");
    };

    const clampPage = () => {
      if (!pdfDoc) return;
      const totalPages = pdfDoc.numPages;
      const maxLeftPage = totalPages % 2 === 0 ? totalPages - 1 : totalPages;
      const singleMode = useSingleView();
      const maxPage = singleMode ? totalPages : maxLeftPage;
      currentPage = Math.max(1, Math.min(currentPage, maxPage));
    };

    prevBtn.addEventListener("click", () => {
      const step = useSingleView() ? 1 : 2;
      currentPage = Math.max(1, currentPage - step);
      renderSpread();
    });

    nextBtn.addEventListener("click", () => {
      const step = useSingleView() ? 1 : 2;
      currentPage = currentPage + step;
      clampPage();
      renderSpread();
    });

    window.addEventListener("keydown", (event) => {
      if (event.key === "ArrowRight") {
        nextBtn.click();
      }
      if (event.key === "ArrowLeft") {
        prevBtn.click();
      }
    });

    let resizeTimer = null;
    window.addEventListener("resize", () => {
      if (resizeTimer) window.clearTimeout(resizeTimer);
      resizeTimer = window.setTimeout(() => {
        clampPage();
        renderSpread();
      }, 150);
    });

    pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
    pdfjsLib.getDocument(pdfUrl).promise
      .then(async (pdf) => {
        pdfDoc = pdf;
        const firstPage = await pdfDoc.getPage(1);
        const firstViewport = firstPage.getViewport({ scale: 1 });
        forceSingle = firstViewport.width / firstViewport.height > 1.1;
        currentPage = 1;
        clampPage();
        renderSpread();
      })
      .catch((error) => {
        console.error(error);
        loadingEl.textContent = "Unable to load the portfolio. Please use the Open PDF link.";
      });
  </script>
</body>
</html>
